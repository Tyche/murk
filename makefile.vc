#
# Murk++ build for visual c++
#
CPP = cl
CC = cl
AR = link
LD = cl
WINZIP = C:\apps\Winzip\wzzip

# Compiler directives for debugging
!ifdef DEBUG
DEBUG_CFLAGS = /MLd /ZI /Od /FD /GZ /D "DEBUG" 
DEBUG_LFLAGS = /DEBUG /PDBTYPE:SEPT 
LIBS= libcd.lib kernel32.lib ws2_32.lib libcpd.lib 
!else
DEBUG_CFLAGS = /ML /O2 /D "NDEBUG" 
DEBUG_LFLAGS = 
LIBS= libc.lib kernel32.lib ws2_32.lib libcp.lib
!endif

DEFS= /D "WIN32" /D "WIN32_LEAN_AND_MEAN" /D "_CONSOLE" /D "_MBCS" /D "NDEBUG"
OPTIM= /nologo /GX /W1 $(DEBUG_CFLAGS) # /G$(PROCESSOR_LEVEL) 
CFLAGS= $(OPTIM) $(DEFS)
LFLAGS = /link /NOLOGO /NODEFAULTLIB /SUBSYSTEM:CONSOLE $(DEBUG_LFLAGS) 

INCS = /Isqlite3

SQLITE_SRC = sqlite3\alter.c sqlite3\analyze.c sqlite3\attach.c \
	sqlite3\auth.c sqlite3\btree.c sqlite3\build.c sqlite3\callback.c \
	sqlite3\complete.c sqlite3\date.c sqlite3\delete.c sqlite3\expr.c \
	sqlite3\func.c sqlite3\hash.c sqlite3\insert.c sqlite3\legacy.c \
	sqlite3\loadext.c sqlite3\main.c sqlite3\opcodes.c sqlite3\os.c \
	sqlite3\os_unix.c sqlite3\os_win.c sqlite3\pager.c sqlite3\parse.c \
	sqlite3\pragma.c sqlite3\prepare.c sqlite3\printf.c sqlite3\random.c \
	sqlite3\select.c sqlite3\table.c sqlite3\tokenize.c sqlite3\trigger.c \
	sqlite3\update.c sqlite3\utf.c sqlite3\util.c sqlite3\vacuum.c \
	sqlite3\vdbe.c sqlite3\vdbeapi.c sqlite3\vdbeaux.c sqlite3\vdbefifo.c \
	sqlite3\vdbemem.c sqlite3\vtab.c sqlite3\where.c
SQLITE_OBJ = $(SQLITE_SRC:.c=.obj)
SQLITE_LIB = sqlite3\sqlite3.lib

SQLITE_PRG_SRC = sqlite3\shell.c 
SQLITE_PRG_OBJ = $(SQLITE_PRG_SRC:.c=.obj)
SQLITE_PRG = sqlite3\sqlite3.exe 

SQLITE_XTRA = sqlite3\sqlite3.def sqlite3\btree.h \
	sqlite3\os.h sqlite3\sqlite3.h sqlite3\vdbeInt.h sqlite3\hash.h \
	sqlite3\os_common.h sqlite3\sqlite3ext.h sqlite3\keywordhash.h \
	sqlite3\pager.h sqlite3\sqliteInt.h sqlite3\opcodes.h sqlite3\parse.h \
	sqlite3\vdbe.h

MURK_UTIL_SRC = loadhelps.cpp
MURK_UTIL_OBJ = $(MURK_UTIL_SRC:.cpp=.obj)
MURK_SRC = murk.cpp os.cpp descriptor.cpp utils.cpp commands.cpp io.cpp \
	room.cpp object.cpp character.cpp spells.cpp objproto.cpp mobproto.cpp \
	affect.cpp exit.cpp area.cpp reset.cpp extra.cpp shop.cpp
MURK_OBJ = $(MURK_SRC:.cpp=.obj)
MURK_HDR = os.hpp config.hpp descriptor.hpp character.hpp pcdata.hpp utils.hpp \
	globals.hpp object.hpp note.hpp room.hpp area.hpp mobproto.hpp \
	objproto.hpp affect.hpp exit.hpp extra.hpp ban.hpp shop.hpp reset.hpp \
	io.hpp 

# Data files Areas, Mobprogs and Players
DATAFILES = area.lst limbo.are mid_cit.prg midgaard.are school.are help.are \
        vagabond.prg beggar.prg crier.prg drunk.prg gategrd.prg gategrd2.prg \
	janitor.prg One schema item_types socials titles

# Files in the standard distribution
DISTFILES = $(MURK_SRC) $(MURK_UTIL_SRC) $(MURK_HDR) $(DATAFILES) \
	$(SQLITE_SRC) $(SQLITE_PRG_SRC) $(SQLITE_XTRA) \
	makefile makefile.bor makefile.vc makefile.dgm \
	doc.txt startup license.crypt license.diku license.merc license.murk++ 
  
!ifndef RELEASE
RELEASE=dist
!endif

TARGETS = $(SQLITE_LIB) $(SQLITE_PRG) murk.exe loadhelps.exe

all: $(TARGETS)

$(SQLITE_LIB): $(SQLITE_OBJ)
	$(AR) /LIB -OUT:$@ $**

$(SQLITE_PRG): $(SQLITE_PRG_OBJ) $(SQLITE_LIB)
	$(AR) -OUT:$@ $**

murk.exe: $(MURK_OBJ) $(SQLITE_LIB)
	$(LD) $** $(LIBS) /Fe$@ $(LFLAGS)

loadhelps.exe: $(MURK_UTIL_OBJ) io.obj utils.obj $(SQLITE_LIB) 
	$(CPP) $(LFLAGS) -o $@ $^ $(LIBS)

database: $(SQLITE_PRG)
	@echo "Building database..."
	@-copy murk.db murk.db.bkup
	@-del murk.db
	@sqlite3\sqlite3 murk.db < schema
	@sqlite3/sqlite3 murk.db < schema
	@echo "Done."

clean:
	@-del *.pdb *.ilk *.idb $(TARGETS) $(MURK_OBJ) $(SQLITE_OBJ) \
	$(SQLITE_PRG_OBJ) 2>NUL

dist : $(DISTFILES)
	@echo "Building distribution..."
	@-md murk++
	@!copy /y "$**" "murk++" 1>NUL
	@echo .svn > ex.tmp
        @xcopy sqlite3 "murk++\sqlite3" /I /E /Y /Q /EXCLUDE:ex.tmp 
        @del ex.tmp
	@$(WINZIP) -Pr murk++-$(RELEASE).zip murk++ 1>NUL 2>NUL
	@rd /s /q murk++
	@echo "Done."

.c.obj:
	$(CC) $(CFLAGS) $(INCS) /Fo$@ /c $<


.cpp.obj:
	$(CC) $(CFLAGS) $(INCS) /Fo$@ /c $<
